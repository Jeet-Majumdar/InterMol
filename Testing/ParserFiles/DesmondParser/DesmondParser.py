import pdb #FOR DEBUGGING PURPOSES
import shlex
import os
import copy
import string
import re
import sys
import simtk.unit as units
from collections import deque
sys.path.append('../..')
from Atom import *
from Molecule import *
from System import System
from Types import *
from Force import *
from HashMap import *


class DesmondParser():
    """
    A class containing methods required to read in Desmond CMS File   
    """

    def __init__(self,defines=None):
      """
      Initializes a DesmondParse object which serves to read in a CMS file
      into the abstract representation.
    
      Args:
      defines: Sets of default defines to use while parsing.
      """
      self.includes = set()       # set storing includes
      self.defines = dict()        # list of defines
      self.comments = list()      # list of comments
        
      self.atomtypes = HashMap()
      self.bondtypes = HashMap()
      self.pairtypes = HashMap()
      self.angletypes = HashMap()
      self.dihedraltypes = HashMap()
      self.constrainttypes = HashMap()
        
      if defines:
        self.defines.union(defines)
      self.defines["FLEX_SPC"] = None
      self.defines["POSRE"] = None 
      self.viparr = 1
      
      self.fblockpos = []
      self.a_blockpos = []
      self.b_blockpos = []
      self.ffio_blockpos = []
  
#LOAD FFIO BLOCKS IN FIRST (CONTAINS TOPOLOGY)

    def loadFfio(self, lines, moleculeName, start, end, sysDirective, sysDirectiveAtm, verbose = False):
	                  
#        Loading in ffio blocks from Desmond format
	
#        Args:
#            lines: list of all data in CMS format	
	    
#	     moleculeName: name of current molecule
	    
#	     start: beginning of where ffio_ff starts for each molecule
	    
#	     end: ending of where ffio_ff ends for each molecule
	    
#	    sysDirective: help locate positions of specific data in ffio blocks
	    
#	    sysDirectiveAtm: help locate positions of specific data in m_atoms
      i = start
      j = start
      vdwtypeskeys = []
      vdwtypes = []
      split = []
      constraints = []
      temp = []
      #moleculeName = None 
      currentMolecule = None
      currentMoleculeType = None
      newAtomType = None
      newBondForce = None
      newBondType = None
      newPairType = None
      newPairForce = None
      newAngleType = None
      newAngleForce = None
      newDihedralType = None
      newDihedralForce = None
      stemp = None
      etemp = None
      sigma = None
      epsilon = None
      atomlist = None
      namecol = 0
      combrcol = 0
      
      #DEFAULT VALUES WHEN CONVERTING TO GROMACS
      System._sys._nbFunc = 1
      System._sys._genpairs = 'yes'

      if re.search("TIP3P", moleculeName):
        moleculeName = "H2O"
	#return

      if verbose:
	print 'Parsing [ molecule %s]'%(moleculeName)
        print "Parsing [ ffio]"

      while i < end:

	if i == start:
          while not re.match(r'\s*[:::]',lines[i]):
	    if re.match('\s*s_ffio_name',lines[i]):
	      namecol = i-start
	    elif re.match('\s*s_ffio_comb_rule',lines[i]):
	      combrcol = i-start
            i+=1
	    j+=1
	  i+=1
          while (i-j) < (j-start-1):
	   # if namecol == i-j:
	   #   if re.match('\s*"Generated by viparr"',lines[i]): #If a CMS Ffio block is generated by Viparr, then the name changes to "Generated by Viparr"
	   #     moleculeName = "Viparr%d"%self.viparr              #This replaces the name of molecule with Viparr
	   #     self.viparr+=1
	   #     #print "VIPARR GENERATED" 
	   #   else:
	   #     moleculeName = lines[i].split()
	   #     #print "Molecule Name there"
            if combrcol == i-j:
	      if re.search("Geometric", lines[i], re.IGNORECASE):
		if re.search("Arithmetic", lines[i], re.IGNORECASE):
	          System._sys._combinationRule = 3
		else:
	          System._sys._combinationRule = 2
              elif re.search("Arithmetic", lines[i], re.IGNORECASE):
	        System._sys._combinationRule = 1
	    i+=1
	  i+=1

        currentMolecule = Molecule(moleculeName)
        match = sysDirective.match(lines[i])

        if match:

          if match.group('vdwtypes'): #molecule name is at sites, but vdwtypes comes before sites. So we store info in vdwtypes and edit it later at sites
            if verbose:
              print "Parsing [ vdwtypes]..."
	    i+=6 #ASSUMING ALL COLUMNS AT VDWTYPES ARE THE SAME
	    while not re.match(r'\s*[:::]',lines[i]):
  	      vdwtypes.append(lines[i].split()[3:]) #THIS IS ASSUMING ALL VDWTYPES ARE LJ12_6_SIG_EPSILON
	      vdwtypeskeys.append(lines[i].split()[1])
	      i+=1

          elif match.group('sites'):   #correlate with atomtypes and atoms in GROMACS
            if verbose:                #also edit vdwtypes
              print "Parsing [ sites]..." 
	    length =  lines[i][(lines[i].find('[', None, None) + 1):(lines[i].find(']', None, None))]
	    i+=1
	    while not re.match(r'\s*[:::]',lines[i]):
	      i+=1
	    cgnr = 1
	    i+=1
	    while not re.match(r'\s*[:::]',lines[i]):
	      split = lines[i].split() 
	      stemp = float(vdwtypes[vdwtypeskeys.index(split[4])][0]) * 0.1 * units.nanometers #was in angstroms
	      etemp = float(vdwtypes[vdwtypeskeys.index(split[4])][1]) * 4.184 * units.kilojoules_per_mole #was in kilocal per mol

              if split[1] == "atom":
  	        if len(split) == 7: 
 	          atom = Atom(int(split[0]), split[4], int(split[5]), split[6]) #adding in index, vdwtype, resnr, residue
	        else:
	          atom = Atom(int(split[0]), split[4], 0, '') # IS PLACEHOLDER FOR ANYTHING WITH NO RESIDUE NUMBER
	        atom.setAtomType(0, split[4])
	        atom.setCharge(0, float(split[2])*units.elementary_charge) #NEED TO CONVERT TO ACTUAL UNITS
	        atom.setMass(0, float(split[3]) * units.amu)
		stemp = float(vdwtypes[vdwtypeskeys.index(split[4])][0]) * 0.1 * units.nanometers #was in angstroms
		etemp = float(vdwtypes[vdwtypeskeys.index(split[4])][1]) * 4.184 * units.kilojoules_per_mole #was in kilocal per mol
	        atom.setSigma(0, stemp) 
	        atom.setEpsilon(0, etemp) 
                atom.cgnr = cgnr
                cgnr+=1
		
		currentMolecule.addAtom(atom)

		if not System._sys._atomtypes.get(AbstractAtomType(atom.getAtomType().get(0))): #if atomtype not in System, add it
	          if System._sys._combinationRule == 1:
		    sigma = (etemp/stemp)**(1/6)
		    epsilon = (stemp)/(4*sigma**6)
		    newAtomType = AtomCR1Type(split[4],             #atomtype/name 
		                  split[4],                             #bondtype
		                  -1,                               #Z
		                  float(split[2]) * units.amu,      #mass
		                  float(split[3]) * units.elementary_charge,  #charge--NEED TO CONVERT TO ACTUAL UNIT
		                  'A',                             #pcharge...saw this in top--NEED TO CONVERT TO ACTUAL UNITS
		                  sigma * units.kilojoules_per_mole * units.nanometers**(6),  
		                  epsilon * units.kilojoules_per_mole * units.nanometers**(12))  
		  elif (System._sys._combinationRule == 2) or (System._sys._combinationRule == 3):
		    newAtomType = AtomCR23Type(split[4], #atomtype/name 
		                  split[4],                 #bondtype
		                  -1,                   #Z
               	                  float(split[2]) * units.amu,  #mass--NEED TO CONVERT TO ACTUAL UNITS
		                  float(split[3]) * units.elementary_charge,  #charge--NEED TO CONVERT TO ACTUAL UNIT
		                  'A',                  #pcharge...saw this in top--NEED TO CONVERT TO ACTUAL UNITS
		                  stemp,
		                  etemp) 
		  System._sys._atomtypes.add(newAtomType)
	      i+=1 

	    if len(self.a_blockpos) > 1:  #LOADING M_ATOMS
	      if self.a_blockpos[0] < start:
		currentMolecule._atoms = self.loadMAtoms(lines, self.a_blockpos[0], i, currentMolecule, (int)(length), sysDirectiveAtm, verbose)
		self.a_blockpos.pop(0)
            
            System._sys.addMolecule(currentMolecule)
            currentMoleculeType = System._sys._molecules[moleculeName]
	    currentMoleculeType.nrexcl = 3 #PLACEHOLDER FOR NREXCL....FIND OUT WHERE IT IS
	    
	    atomlist = copy.deepcopy(currentMolecule._atoms)


	  elif match.group('bonds'): #add more stuff to this later once you have more samples to work with
            forces = []
	    if len(self.b_blockpos) > 1:  #LOADING M_BONDS
	      #print 'LENGTH OF B_BLOCKPOS: %d'%len(self.b_blockpos)
	      if self.b_blockpos[0] < start:
		forces = self.loadMBonds(lines,self.b_blockpos[0], i, verbose)
		currentMoleculeType.bondForceSet = forces[0]
		System._sys._forces = forces[1]
		self.b_blockpos.pop(0)
	    if verbose:
              print "Parsing [ bonds]..."
	    i+=7
	    while not re.match(r'\s*[:::]',lines[i]):
	      split = lines[i].split()
	      newBondForce = None
	      if re.match("Harm_constrained", split[3]):
                try:
    		  newBondType = BondType(atomlist[int(split[1])-1].atomName,
                                atomlist[int(split[2])-1].atomName,
                                1,
                                float(split[4]) * 0.1 * units.nanometers, #UNITS IN ANGSTROMS--CHECK
                                float(split[5]) * 4.184 * 100 * units.kilojoules_per_mole * units.nanometers**(-2), #COME BACK TO THESE UNITS
				1)
 	        except:
		  newBondType = BondType(atomlist[int(split[1])-1].atomName,
                                atomlist[int(split[2])-1].atomName,
                                1,
                                float(split[4]), 
                                float(split[5]),
				1)		
		try:
	          newBondForce = Bond(int(split[1]),
		                 int(split[2]),
                                 float(split[4]) * 0.1 * units.nanometers, #UNITS IN ANGSTROMS...CHECK
                                 float(split[5]) * 4.184 * 100 * units.kilojoules_per_mole * units.nanometers**(-2),
                                 None,
				 1)
	        except:
	          newBondForce = Bond(int(split[1]),
		                 int(split[2]),
                                 float(split[4]),
                                 float(split[5]),
                                 None,
				 1)
				 
	      elif re.match("Harm",split[3]):
	        #print "LOCATED HARM"
                try:
    		  newBondType = BondType(atomlist[int(split[1])-1].atomName,
                                atomlist[int(split[2])-1].atomName,
                                1,
                                float(split[4]) * 0.1 * units.nanometers, #UNITS IN ANGSTROMS--CHECK
                                float(split[5]) * 4.184 * 100 * units.kilojoules_per_mole * units.nanometers**(-2), #COME BACK TO THESE UNITS
				0)
 	        except:
		  newBondType = BondType(atomlist[int(split[1])-1].atomName,
                                atomlist[int(split[2])-1].atomName,
                                1,
                                float(split[4]), 
                                float(split[5]),
				0)		
		try:
	          newBondForce = Bond(int(split[1]),
		                 int(split[2]),
                                 float(split[4]) * 0.1 * units.nanometers, #UNITS IN ANGSTROMS...CHECK
                                 float(split[5]) * 4.184 * 100 * units.kilojoules_per_mole * units.nanometers**(-2),
                                 None,
				 0)
	        except:
	          newBondForce = Bond(int(split[1]),
		                 int(split[2]),
                                 float(split[4]),
                                 float(split[5]),
                                 None,
				 0)
	      else:
		print "ERROR (readFile): found unsupported bond"
#	        print "FOUND NEW BOND TYPE AT LINE %d AND CALLED %s"%(i, split[3])
#		newBondType = BondType(atomlist[int(split[1])-1].atomName,
#                              atomlist[int(split[2])].atomName,
#                              1,
#                              float(split[4]) * 0.1 * units.nanometers,
#                              float(split[5]) * 4.184 * 100 * units.kilojoules_per_mole * units.nanometers**(-2))
#	        newBondForce = Bond(int(split[1]),
#		               int(split[2]),
#                               float(split[4]) * 0.1 * units.nanometers,
#                               float(split[5]) * 4.184 * 100 * units.kilojoules_per_mole * units.nanometers**(-2),
#                               None,
#			       0)
              if newBondForce:
                if newBondForce in currentMoleculeType.bondForceSet: #bondForceSet already contains i,j, bond order
	          oldBondForce = currentMoleculeType.bondForceSet.get(newBondForce)
		  currentMoleculeType.bondForceSet.remove(newBondForce)
		  newBondForce.order = oldBondForce.order
	        currentMoleculeType.bondForceSet.add(newBondForce)
	        System._sys._forces.add(newBondForce)
	      if newBondType and newBondType not in self.bondtypes:
	        self.bondtypes.add(newBondType)
		
	      i+=1
	      

          elif match.group('pairs'): #GromacsTopology didn't fix this, so fix this when changes are made
            if verbose:
              print "Parsing [ pairs]..."
	    i+=6 #ASSUMING ALL COLUMNS OF PAIRS ARE THE SAME
	    funct1_lj = []
	    funct1_cl = []
	    funct1_both = []
	    ljch=None
	    clomb=None
	    lj = False
	    cl = False
            tempcnt = 0
	    while not re.match(r'\s*[:::]',lines[i]): #organzies pair data into 4 types above
	      split = lines[i].split()
	      if int(split[0]) == 1:
	        if re.match(split[3], "LJ"):
		  ljch = float(split[4])
		  lj = True
		  funct1_lj.append([int(split[1]),int(split[2])])
		else:
		  clomb = float(split[4])
		  cl = True
		  funct1_cl.append([int(split[1]),int(split[2])])
	      elif lj:
		if re.match(split[3], "Coulomb"):
	          if not clomb:
                    clomb = float(split[4])
		  cl = True
		  lj = False 
	      elif cl:
		if re.match(split[3], "LJ"):
	          if not ljch:
                    ljch = float(split[4])
		  cl = False
		  lj = True
	      if not int(split[0]) == 1:
	        if lj and [int(split[1]), int(split[2])] in funct1_cl:
	  	  funct1_cl.remove([int(split[1]), int(split[2])])
		  funct1_both.append([int(split[1]), int(split[2])])
	        elif cl and [int(split[1]), int(split[2])] in funct1_lj:
	          funct1_lj.remove([int(split[1]), int(split[2])])
		  funct1_both.append([int(split[1]), int(split[2])])
	        else:
		  if lj:
		    funct1_lj.append([int(split[1]),int(split[2])])
		  else:
		    funct1_cl.append([int(split[1]),int(split[2])])	
              i+=1
	    System._sys._ljCorrection = float(ljch)
            System._sys._coulombCorrection = float(clomb)
	    	    
	    for a in funct1_lj:     #PUT ALL PAIRS WITH ONLY LJ INTO LJ1
	      newPairForce = AbstractPair(a[0], a[1], "LJ") 
              currentMoleculeType.pairForceSet.add(newPairForce)
	      System._sys._forces.add(newPairForce)
	      
#	      if System._sys._combinationRule == 1:
#                newPairType = LJ1PairCR1Type(atomlist[a[0]-1].atomName,  #atom 1 and index
#                                atomlist[a[1]-1].atomName,              #atom 2 and index
#                                1,                                     #type
#                                float(0) * units.kilojoules_per_mole * units.nanometers**(6),  #COME BACK
#                                float(0) * units.kilojoules_per_mole * units.nanometers**(12)) #COME BACK
#	      elif System._sys._combinationRule == (2 or 3):
#                newPairType = LJ1PairCR23Type(atomlist[a[0]-1].atomName,
#                                atomlist[a[1]-1].atomName,
#				 1,
#                                float(0) * units.nanometers,          #COME BACK
#                                float(0) * units.kilojoules_per_mole) #COME BACK
#	      self.pairtypes.add(newPairType)
	   
	    for a in funct1_cl: #PUT ALL PAIRS WITH ONLY CL INT LJ1
	      newPairForce = AbstractPair(a[0], a[1], "Coulomb") 
              currentMoleculeType.pairForceSet.add(newPairForce)
	      System._sys._forces.add(newPairForce)
	      
#	      if System._sys._combinationRule == 1:
#                newPairType = LJ1PairCR1Type(atomlist[a[0]-1].atomName,  #atom 1 and index
#                                atomlist[a[1]-1].atomName,               #atom 2 and index
#                                1,                                     #type
#                                float(0) * units.kilojoules_per_mole * units.nanometers**(6),  #COME BACK
#                                float(0) * units.kilojoules_per_mole * units.nanometers**(12)) #COME BACK
#	      elif System._sys._combinationRule == (2 or 3):
#                newPairType = LJ1PairCR23Type(atomlist[a[0]-1].atomName,
#                                atomlist[a[1]-1].atomName,
#				 1,
#                                float(0) * units.nanometers,          #COME BACK
#                                float(0) * units.kilojoules_per_mole) #COME BACK
#	      self.pairtypes.add(newPairType)
	      
	    for a in funct1_both: #PUT ALL PAIRS WITH BOTH LJ AND COULOMB INTO NB 
	      newPairForce = AbstractPair(a[0], a[1], "Both")
              currentMoleculeType.pairForceSet.add(newPairForce)
	      System._sys._forces.add(newPairForce)
	      
#	      if System._sys._combinationRule == 1:
#                newPairType = LJNBPairCR1Type(atomlist[a[0]-1].atomName, #atom 1 and index
#                                atomlist[a[1]-1].atomName,               #atom 2 and index
#                                2,                                     #type
#				float(ljch) * units.elementary_charge, #UNITS CORRECT???
#                                float(clomb) * units.elementary_charge, #UNITS CORRECT???
#                                float(0) * units.kilojoules_per_mole * units.nanometers**(6),  #COME BACK
#                                float(0) * units.kilojoules_per_mole * units.nanometers**(12)) #COME BACK
#	      elif System._sys._combinationRule == (2 or 3):
#                newPairType = LJNBPairCR23Type(atomlist[a[0]-1].atomName,
#                                atomlist[a[1]-1].atomName,
#                                2,
#				float(ljch) * units.elementary_charge, #UNITS CORRECT???
#                                float(clomb) * units.elementary_charge, #UNITS CORRECT???
#                                float(0) * units.nanometers,          #COME BACK
#                                float(0) * units.kilojoules_per_mole) #COME BACK
#	      self.pairtypes.add(newPairType)

	    
          elif match.group('angles'): #add more stuff later once you have more samples to work with
            if verbose:
              print "Parsing [ angles]..."
            #print "angles at line %d"%i
	    i+=8 #ASSUMING ALL ANGLE COLUMNS HAVE SAME 6
	    while not re.match(r'\s*[:::]',lines[i]):
	      split = lines[i].split()
	      newAngleForce = None
	      #Angle
	      if re.match("Harm", split[4]):
#	        newAngleType = AngleType(atomlist[int(split[1])-1],
#		               atomlist[int(split[2])-1],
#			       atomlist[int(split[3])-1],
#			       1,
#			       float(split[5]) * units.degrees,
#			       float(split[6]) * units.kilojoules_per_mole * units.radians**(-2)) #UNITS??
		try:
		  newAngleForce = Angle(int(split[1]),
		                  int(split[2]),
				  int(split[3]),
				  float(split[5]) * units.degrees,
				  float(split[6]) * units.kilojoules_per_mole * units.radians **(-2)) #UNITS???
                                  #0)
		except:
		  newAngleForce = Angle(int(split[1]),
		                  int(split[2]),
				  int(split[3]),
				  float(split[5]),
				  float(split[6]))

              elif re.match("Harm_constrained",split[4]):
#	        newAngleType = AngleType(atomlist[int(split[1])-1],
#		               atomlist[int(split[2])-1],
#			       atomlist[int(split[3])-1],
#			       1,
#			       float(split[5]) * units.degrees,
#			       float(split[6]) * units.kilojoules_per_mole * units.radians**(-2)) #UNITS??
		try:
		  newAngleForce = Angle(int(split[1]),
		                  int(split[2]),
				  int(split[3]),
				  float(split[5]) * units.degrees,
				  float(split[6]) * units.kilojoules_per_mole * units.radians **(-2), #UNITS???
                                  1)
		except:
		  newAngleForce = Angle(int(split[1]),
		                  int(split[2]),
				  int(split[3]),
				  float(split[5]),
				  float(split[6]),
                                  1)
	      else:
#	        print "NEW ANGLE TYPE AT LINE %d AND CALLED %s"%(i, split[4])
                print "ERROR (readFile): found unsupported angle"

	      if newAngleForce:
                currentMoleculeType.angleForceSet.add(newAngleForce)
	        System._sys._forces.add(newAngleForce)
#	        self.angletypes.add(newAngleType)

	      i+=1

          elif match.group('dihedrals'):
            if verbose:
              print "Parsing [ dihedrals]..."
	    dtype = 0
	    while not re.match(r'\s*[:::]',lines[i]):
	      i+=1
	      dtype+=1
	    i+=1
	    while not re.match(r'\s*[:::]',lines[i]):
	      split = lines[i].split()
	      newDihedralForce = None
	      #Proper Diehdral 1 ---NOT SURE ABOUT MULTIPLICITY
              if re.match(split[5], "PROPER_HARM", re.IGNORECASE): 
#		newDihedralType = ProperDihedral1Type(atomlist[int(split[1])-1],
#		                  atomlist[int(split[2])-1],
#				  atomlist[int(split[3])-1],
#				  atomlist[int(split[4])-1],
#				  1,
#                                  float(split[6]) * units.degrees,
#                                  float(split[7]) * 4.18 * units.kilojoules_per_mole * (0.01745 * units.radians) **(-2), #UNITS??? DESMOND SAYS UNITS IN ENERGY/DEGREE^2, GROMACS SAYS UNITS IN KJ/MOL / RADIAN ^2
#				  2)
                try:
                  newDihedralForce = ProperDihedral1(int(split[1]),
                                     int(split[2]),
                                     int(split[3]),
                                     int(split[4]),
                                     float(split[6]) * units.degrees,
                                     float(split[7]) * 4.184 * units.kilojoules_per_mole * ((0.01745 * units.radians) **(-2)), #UNITS??? DESMOND SAYS UNITS IN ENERGY/DEGREE^2, GROMACS SAYS UNITS IN KJ/MOL / RADIAN ^2
                                     2)
                except:
                  newDihedralFroce = ProperDihedral1(int(split[1]),
                                     int(split[2]),
                                     int(split[3]),
                                     int(split[4]),
                                     split[6],
                                     split[7],
                                     2)
              
	      #Improper Diehdral 2 ---NOT SURE ABOUT MULTIPLICITY
              elif re.match(split[5], "IMPROPER_HARM", re.IGNORECASE): 
#		newDihedralType = ImproperDihedral2Type(atomlist[int(split[1])-1],
#		                  atomlist[int(split[2])-1],
#				  atomlist[int(split[3])-1],
#				  atomlist[int(split[4])-1],
#				  1,
#                                  float(split[6]) * units.degrees,
#                                  float(split[7]) * 4.18 * units.kilojoules_per_mole * (0.01745 * units.radians) **(-2))
                try:
                  newDihedralForce = ImproperDihedral2(int(split[1]),
                                     int(split[2]),
                                     int(split[3]),
                                     int(split[4]),
                                     float(split[6]) * units.degrees,
                                     float(split[7]) * 4.184 * units.kilojoules_per_mole * ((0.01745 * units.radians) **(-2)))
                except:
                  newDihedralFroce = ImproperDihedral2(int(split[1]),
                                     int(split[2]),
                                     int(split[3]),
                                     int(split[4]),
                                     split[6],
                                     split[7])
	      
              #RB Dihedral (Assume for Improper trig and Proper trig for now)
	      elif re.match(split[5], "PROPER_TRIG", re.IGNORECASE): # ASSUME IT CORRELATE TO RB DIHEDRAL (LAST PARAMETER IS ALWAYS 0)
#		newDihedralType = RBDihedralType(atomlist[int(split[1])-1],
#		                  atomlist[int(split[2])-1],
#				  atomlist[int(split[3])-1],
#				  atomlist[int(split[4])-1],
#				  3,
#                                  float(split[6]) * 4.184 * units.kilojoules_per_mole,
#                                  float(split[7]) * 4.184 * units.kilojoules_per_mole,
#                                  float(split[8]) * 4.184 * units.kilojoules_per_mole,
#                                  float(split[9]) * 4.184 * units.kilojoules_per_mole,
#                                  float(split[10]) * 4.184 * units.kilojoules_per_mole,
#                                  float(split[11]) * 4.184 * units.kilojoules_per_mole)
                try:
                  newDihedralForce = RBDihedral(int(split[1]),
                                     int(split[2]),
                                     int(split[3]),
                                     int(split[4]),
                                     float(split[6]) * 4.184 * units.kilojoules_per_mole,
                                     float(split[7]) * 4.184 * units.kilojoules_per_mole,
                                     float(split[8]) * 4.184 * units.kilojoules_per_mole,
                                     float(split[9]) * 4.184 * units.kilojoules_per_mole,
                                     float(split[10]) * 4.184 * units.kilojoules_per_mole,
                                     float(split[11]) * 4.184 * units.kilojoules_per_mole)
                except:
                  newDihedralForce = RBDihedral(int(split[1]),
                                     int(split[2]),
                                     int(split[3]),
                                     int(split[4]),
                                     float(split[6]),
                                     float(split[7]),
                                     float(split[8]),
                                     float(split[9]),
                                     float(split[10]),
                                     float(split[11]))

	      elif re.match(split[5], "IMPROPER_TRIG", re.IGNORECASE): #SAME TYPE AS PROPER
#		newDihedralType = RBDihedralType(atomlist[int(split[1])-1],
#		                  atomlist[int(split[2])-1],
#				  atomlist[int(split[3])-1],
#				  atomlist[int(split[4])-1],
#				  3,
#                                  float(split[6]) * 4.184 * units.kilojoules_per_mole,
#                                  float(split[7]) * 4.184 * units.kilojoules_per_mole,
#                                  float(split[8]) * 4.184 * units.kilojoules_per_mole,
#                                  float(split[9]) * 4.184 * units.kilojoules_per_mole,
#                                  float(split[10]) * 4.184 * units.kilojoules_per_mole,
#                                  float(split[11]) * 4.184 * units.kilojoules_per_mole)
                try:
                  newDihedralForce = RBDihedral(int(split[1]),
                                     int(split[2]),
                                     int(split[3]),
                                     int(split[4]),
                                     float(split[6]) * 4.184 * units.kilojoules_per_mole,
                                     float(split[7]) * 4.184 * units.kilojoules_per_mole,
                                     float(split[8]) * 4.184 * units.kilojoules_per_mole,
                                     float(split[9]) * 4.184 * units.kilojoules_per_mole,
                                     float(split[10]) * 4.184 * units.kilojoules_per_mole,
                                     float(split[11]) * 4.184 * units.kilojoules_per_mole,
				     1) #IMPROPER
                except:
                  newDihedralForce = RBDihedral(int(split[1]),
                                     int(split[2]),
                                     int(split[3]),
                                     int(split[4]),
                                     float(split[6]),
                                     float(split[7]),
                                     float(split[8]),
                                     float(split[9]),
                                     float(split[10]),
                                     float(split[11]),
				     1) #IMPROPER
                
              else:
#	        print "NEW DIHEDRAL TYPE AT LINE %d AND CALLED %s"%(i, split[5])
                print "ERROR (readFile): found unsupported dihedral"
	      if newDihedralForce:
	        currentMoleculeType.dihedralForceSet.add(newDihedralForce)
                System._sys._forces.add(newDihedralForce)		    
#               self.dihedraltypes.add(newDihedralType)
	      i+=1
	    #9 proper dihedrals, funct = 1
	    #3 improper dihedrals, funct = 2
	    #Ryckaert-Bellemans type dihedrals, funct = 3 and pairs are removed

          elif match.group('constraints'):
            if verbose:
              print "Parsing [ constraints]..."
	    ctype = 0
	    funct_pos = 0
	    atompos = [] #position of atoms in constraints; spread all over the place
	    lenpos = [] #position of atom length; spread all over the place
            tempatom = []
            templength = []
	    templen = 0
	    while not re.match(r'\s*[:::]',lines[i]):
	      if re.match(r'\s*s_ffio_funct', lines[i]):
	        funct_pos = ctype
	      elif re.search('i_ffio', lines[i]):
                atompos.append(ctype)
	      elif re.search('r_ffio', lines[i]):
	        lenpos.append(ctype)
	      i+=1
	      ctype+=1
	    i+=1
	    while not re.match(r'\s*[:::]',lines[i]):
	      split = lines[i].split()
	      if re.match('HOH', split[funct_pos]) or re.search('AH', split[funct_pos]):
                tempatom = []
                templength = []
		for a in atompos:
	          if not re.search('<>',split[a]):
	            tempatom.append(int(split[a]))
		  else:
	            tempatom.append(None)
		for l in lenpos:
	          if not re.search('<>',split[l]):
	            templength.append(float(split[l])*0.1*units.nanometers)
		  else:
	            templength.append(None*units.nanometers)
		if re.search('AH', split[funct_pos]):
                  templen = int(list(split[funct_pos])[-1])
		elif re.match('HOH', split[funct_pos]):
		  templen = 2
		if templen == 1: #THINK LENGTH IS ORIGINALLY IN ANGSTROMS...NOT SURE
		  #newConstraint = Constraint2(tempatom[0],tempatom[1],templength[0])
		  newConstraint = Constraint(tempatom[0],tempatom[1],templength[0],split[funct_pos])
		elif templen == 2:
		  #newConstraint = Constraint3(tempatom[0],tempatom[1],tempatom[2],templength[0],templength[1],templength[2],split[funct_pos]) #AH2 or HOH
		  newConstraint = Constraint(tempatom[0],tempatom[1],templength[0],split[funct_pos],tempatom[2],templength[1],None,templength[2]) #AH2 or HOH
                elif templen == 3:
		  #newConstraint = Constraint4(tempatom[0],tempatom[1],tempatom[2],tempatom[3],templength[0],templength[1],templength[2])
		  newConstraint = Constraint(tempatom[0],tempatom[1],templength[0],split[funct_pos],tempatom[2],templength[1],tempatom[3],templength[2])
		elif templen == 4:
         	  #newConstraint = Constraint5(tempatom[0],tempatom[1],tempatom[2],tempatom[3],tempatom[4],templength[0],templength[1],templength[2],templength[3])
         	  newConstraint = Constraint(tempatom[0],tempatom[1],templength[0],split[funct_pos],tempatom[2],templength[1],tempatom[3],templength[2],tempatom[4],templength[3])
		elif templen == 5:
                  #newConstraint = Constraint6(tempatom[0],tempatom[1],tempatom[2],tempatom[3],tempatom[4],tempatom[5],templength[0],templength[1],templength[2],templength[3],templength[4])
                  newConstraint = Constraint(tempatom[0],tempatom[1],templength[0],split[funct_pos],tempatom[2],templength[1],tempatom[3],templength[2],tempatom[4],templength[3],tempatom[5],templength[4])
		elif templen == 6:
		  #newConstraint = Constraint7(tempatom[0],tempatom[1],tempatom[2],tempatom[3],tempatom[4],tempatom[5],tempatom[6],templength[0],templength[1],templength[2],templength[3],templength[4],templength[5])
		  newConstraint = Constraint(tempatom[0],tempatom[1],templength[0],split[funct_pos],tempatom[2],templength[1],tempatom[3],templength[2],tempatom[4],templength[3],tempatom[5],templength[4],tempatom[6],templength[5])
		elif templen == 7:
		  #newConstraint = Constraint8(tempatom[0],tempatom[1],tempatom[2],tempatom[3],tempatom[4],tempatom[5],tempatom[6],tempatom[7],templength[0],templength[1],templength[2],templength[3],templength[4],templength[5],templength[6])
		  newConstraint = Constraint(tempatom[0],tempatom[1],templength[0],split[funct_pos],tempatom[2],templength[1],tempatom[3],templength[2],tempatom[4],templength[3],tempatom[5],templength[4],tempatom[6],templength[5],tempatom[7],templength[6])
		elif templen == 8:
		  #newConstraint = Constraint9(tempatom[0],tempatom[1],tempatom[2],tempatom[3],tempatom[4],tempatom[5],tempatom[6],tempatom[7],tempatom[8],templength[0],templength[1],templength[2],templength[3],templength[4],templength[5],templength[6],templength[7])
		  newConstraint = Constraint(tempatom[0],tempatom[1],templength[0],split[funct_pos],tempatom[2],templength[1],tempatom[3],templength[2],tempatom[4],templength[3],tempatom[5],templength[4],tempatom[6],templength[5],tempatom[7],templength[6],tempatom[8],templength[7])
	      else:
	        print "ERROR (readFile): found unsupported constraint"
	      if newConstraint:
	        currentMoleculeType.constraints.add(newConstraint)
	        System._sys._forces.add(newConstraint)
	      i+=1

          elif match.group('exclusions'):
            if verbose:
              print "Parsing [ exclusions]..."
	    while not re.match(r'\s*[:::]',lines[i]):
	      i+=1
	    i+=1
	    while not re.match(r'\s*[:::]',lines[i]):
	      temp = lines[i].split()
	      temp.remove(temp[0])
	      newExclusion = Exclusions(temp)
	      currentMoleculeType.exclusions.add(newExclusion)
	      System._sys._forces.add(newExclusion)
	      i+=1

          elif match.group('restraints'):
            if verbose:
              print "Parsing [ restraints]..."
	    while not re.match(r'\s*[:::]',lines[i]):
	      i+=1

        else:
          i+=1  
   
    def loadMBonds(self, lines, start, end, verbose = False): #adds new bonds for each molecule in System
	                  
#        Loading in m_bonds in Desmond format
	
#        Args:
#            lines: list of all data in CMS format
	    
#	    start: beginning of where m_bonds starts for each molecule
	    
#	    end: ending of where m_bondsends for each molecule

      if verbose:
        print "Parsing [ m_bonds]..."
      bg = False
      newBondForce = None
      split = []
      i = start
      bondForceSet = HashMap()
      forces = OrderedSet()
      while i < end:
        if re.match(r'\s*[:::]',lines[i]):
          if bg:
	    break
          else:
            bg = True
	    i+=1
	if bg:
	  split = lines[i].split()
	 
#         newBondType = BondType(atomlist[int(split[1])-1].atomName,
#                                  atomlist[int(split[2])].atomName,
#                                  1,
#                                  float(split[4]) * 0.1 * units.nanometers,
#                                  float(split[5]) * 4.184 * 100 * units.kilojoules_per_mole * units.nanometers**(-2))
	  try:
	    newBondForce = Bond(int(split[1]),
	                   int(split[2]),
			   float(0) * units.nanometers, #BOND ORDERS ARE DIFFERENT, SPLIT3 IS BOND ORDER. NOT ACCURATE CALCULATION
			   float(0) * units.kilojoules_per_mole * units.nanometers**(-2),
			   int(split[3]),
			   0)
	  except:
	    newBondForce = Bond(int(split[1]),
	                   int(split[2]),
			   float(0), 
			   float(0),
			   int(split[3]),
			   0)
	bondForceSet.add(newBondForce)
	forces.add(newBondForce)
#	if newBondType not in self.bondtypes:
#	  self.bondtypes.add(newBondType)
	i+=1
	
      return [bondForceSet, forces]

    def loadMAtoms(self, lines, start, end, currentMolecule, slength, sysDirective, verbose = False): #adds positions and such to atoms in each molecule in System
              
#        Loading in m_atoms from Desmond format
	
#        Args:
#            lines: list of all data in CMS format
	    
#	    start: beginning of where m_atoms starts for each molecule
	    
#	    end: ending of where m_atoms ends for each molecule
	    
#	    currentMolecule
	    
#	    slength: number of unique atoms in m_atoms, used to calculate repetitions
	    
#	    sysDirective: help locate positions of specific data in m_atoms

      if verbose:
        print "Parsing [ m_atoms]..."
      i = start
      xcol = None
      ycol = None
      zcol = None
      rincol = None
      rncol = None
      aicol = None
      an1col = None
      an2col = None
      vxcol = None
      vycol = None
      vzcol = None
      bg = False
      aline1 = ""
      aline2 = ""
      
      mult = (int)((int)(lines[i][(lines[i].find('[', None, None) + 1):(lines[i].find(']', None, None))])/slength) #how many times the atoms repeat
      
      while i < end:
        if re.match(r'\s*[:::]',lines[i]):
          i+=1
          break
        else:
          match = sysDirective.match(lines[i])
          if match:
            if match.group('First'):
              start+=1
            if match.group('xcoord'):
              if verbose:
                print "   Parsing [ xcoord]..."
              xcol = i - start
            elif match.group('ycoord'):   
              if verbose:
                print "   Parsing [ ycoord]..."
              ycol = i - start
            elif match.group('zcoord'):
              if verbose:
                print "   Parsing [ zcoord]..."
              zcol = i - start
            elif match.group('rindex'):
              if verbose:
                print "   Parsing [ rindex]..."
              rincol = i - start
            elif match.group('rname'):
              if verbose:
                print "   Parsing [ rname]..."
	      rncol = i - start
            elif match.group('aindex'):
              if verbose:
                print "   Parsing [ aindex]..."
	      aicol = i - start
            elif match.group('aname1'):
              if verbose:
                print "   Parsing [ aname1]..."
              an1col = i - start
            elif match.group('aname2'):
              if verbose:
                print "   Parsing [ aname2]..."
              an2col = i - start
            elif match.group('xvelocity'):
              if verbose:
                print "   Parsing [ xvelocity]..."
              vxcol = i - start
            elif match.group('yvelocity'):
              if verbose:
                print "   Parsing [ yvelocity]..."
              vycol = i - start
            elif match.group('zvelocity'):
              if verbose:
                print "   Parsing [ zvelocity]..."
   	      vzcol = i - start
        i+=1
      
      atom = None     
 
      newMoleculeAtoms = []
      j = 0
      if verbose:
        print "   Parsing atoms..."
 
      while j < mult:
        for atom in currentMolecule._atoms:
          if re.match(r'\s*[:::]',lines[i]):  
            break  
          else:
            aline = shlex.split(lines[i])
            #pdb.set_trace()
            atom.residueIndex = int(aline[rincol])
            atom.residueName = aline[rncol].strip()
	    atom.atomIndex = int(aline[aicol])
            atom.setPosition(float(aline[xcol]) * 0.1 * units.nanometers, 
                             float(aline[ycol]) * 0.1 * units.nanometers,
	                     float(aline[zcol]) * 0.1 * units.nanometers)
	    if vxcol == vycol == vzcol == None:
	      atom.setVelocity(0.0 * 0.1 * units.nanometers * units.picoseconds**(-1),
	                      (0.0 * 0.1 * units.nanometers) * units.picoseconds**(-1),
	                      (0.0 * 0.1 * units.nanometers) * units.picoseconds**(-1))
            else:
              atom.setVelocity(float(aline[vxcol]) * 0.1 * units.nanometers * units.picoseconds**(-1),
                              float(aline[vycol]) * 0.1 * units.nanometers * units.picoseconds**(-1),
		               float(aline[vzcol]) * 0.1 * units.nanometers * units.picoseconds**(-1))
            aline1 = aline[an1col].strip()
            aline2 = aline[an2col].strip()
            if re.match('$^',aline1) and not re.match('$^',aline2):
	      atom.atomName = aline2
	    elif re.match('$^',aline2) and not re.match('$^',aline1):
	      atom.atomName = aline1
            elif re.search("\d+",aline1) and not re.search("\d+",aline2):
	      if re.search("\D+",aline1) and re.search("\w+",aline1):
                atom.atomName = aline1
              else:
                atom.atomName = aline2 
	    elif re.search("\d+",aline2) and not re.search("\d+",aline1):
	      if re.search("\D+",aline2) and re.search("\w+",aline2):
                atom.atomName = aline2
              else:
                atom.atomName = aline1
	    elif re.match('$^',aline1) and re.match('$^',aline2):
	      atom.atomName = "None"
            else:
	      atom.atomName = aline2  #doesn't matter which we choose, so we'll go with atom name instead of pdb
            if mult == 1:
              newMoleculeAtoms.append(atom)
            else:
              newMoleculeAtoms.append(copy.deepcopy(atom))
	    i+=1
        j+=1
	
      return newMoleculeAtoms


    def loadBoxVector(self, lines, start, end, verbose = False):
	    
 #       Loading Box Vector
 
 #       Create a Box Vector to load into the System
 
#        Args:
#            lines: all the lines of the file stored in an array
#            start: starting position
#            end: ending position

	
      i = start
      v1x = None
      v2x = None
      v3x = None
      v1y = None
      v2y = None
      v3y = None
      v1z = None
      v2z = None
      v3z = None
      while i < end:
        if re.match(r'\s*[\d+]',lines[i]):
          v1x = float(re.sub(r'\s', '', lines[i])) * units.nanometers
          v1y = float(re.sub(r'\s', '', lines[i+1])) * units.nanometers
          v1z = float(re.sub(r'\s', '', lines[i+2])) * units.nanometers
          v2x = float(re.sub(r'\s', '', lines[i+3])) * units.nanometers
          v2y = float(re.sub(r'\s', '', lines[i+4])) * units.nanometers
          v2z = float(re.sub(r'\s', '', lines[i+5])) * units.nanometers
          v3x = float(re.sub(r'\s', '', lines[i+6])) * units.nanometers
          v3y = float(re.sub(r'\s', '', lines[i+7])) * units.nanometers
          v3z = float(re.sub(r'\s', '', lines[i+8])) * units.nanometers
          i = end
        i+=1
      System._sys.setBoxVector(v1x, v2x, v3x, v1y, v2y, v3y, v1z, v2z, v3z)
      
    def readFile(self, filename):

#        Load in data from file
	
#	Read data in Desmond format
        
#        Args:
#            filename: the name of the file to write out to

      lines = list()

      fl = open(filename, 'r')
      lines = list(fl)
      fl.close()
      i,j=0,0

      for line in lines:
        if re.search("f_m_ct",line,re.VERBOSE):
          if j > 0:
            self.fblockpos.append(i)
          j+=1
        if re.search("m_atom",line,re.VERBOSE) and not (re.search("i_m",line)
        or re.search("s_m",line)):
          if j > 1:
            self.a_blockpos.append(i) 
          j+=1
        if re.search("m_bond",line,re.VERBOSE):
          if j > 2:
            self.b_blockpos.append(i)
          j+=1
        if re.search("ffio_ff",line,re.VERBOSE):
          if j > 2:
            self.ffio_blockpos.append(i)
          j+=1
        i+=1
      i-=1
      self.fblockpos.append(i)
      self.a_blockpos.append(i)
      self.b_blockpos.append(i)
      self.ffio_blockpos.append(i)
      verbose = True
      
      sysDirectiveTop = re.compile(r"""
        ((?P<vdwtypes>\s*ffio_vdwtypes\[[\d+]+\])
        |
        (?P<sites>\s*ffio_sites\[[\d+]+\])
        |
        (?P<bonds>\s*ffio_bonds\[[\d+]+\])
        |
        (?P<pairs>\s*ffio_pairs\[[\d+]+\])
        |
        (?P<angles>\s*ffio_angles\[[\d+]+\])
        |
        (?P<dihedrals>\s*ffio_dihedrals\[[\d+]+\])
        |
        (?P<constraints>\s*ffio_constraints\[[\d+]+\])
        |
        (?P<exclusions>\s*ffio_exclusions\[[\d+]+\])
        |
        (?P<restraints>\s*ffio_restraints\[[\d+]+\]))
      """, re.VERBOSE)

      sysDirectiveStr = re.compile(r"""
        ((?P<xcoord>\s*r_m_x_coord)
        |
        (?P<ycoord>\s*r_m_y_coord)
        |
        (?P<zcoord>\s*r_m_z_coord)
        |
        (?P<rindex>\s*i_m_residue_number)
        |
        (?P<rname>\s*s_m_pdb_residue_name)
        |
        (?P<aindex>\s*i_m_atomic_number)
        |
        (?P<aname1>\s*s_m_pdb_atom_name) 
        |
        (?P<aname2>\s*s_m_atom_name)
        |
        (?P<xvelocity>\s*r_ffio_x_vel)
        |
        (?P<yvelocity>\s*r_ffio_y_vel)
        |
        (?P<zvelocity>\s*r_ffio_z_vel)
	|
	(?P<First>\s*[#][\s+]First[\s+]column[\s+]is[\s+]atom[\s+]index[\s+][#]))
      """, re.VERBOSE)

      #LOADING Ffio blocks
      
      print "Reading Ffio Block..."
      i = 0
      j = 0
      while i < (len(self.ffio_blockpos)-1):
        j = self.fblockpos[i]
        while not re.match(r'\s*[:::]',lines[j]):
          j+=1
        self.loadFfio(lines, lines[j+1].strip(), self.ffio_blockpos[i], self.fblockpos[i+1]-1, sysDirectiveTop, sysDirectiveStr,  verbose)
        i+=1
      i = 0

      #LOAD RAW BOX VECTOR-Same throughout cms

      print "Reading Box Vector..."
      self.loadBoxVector(lines, self.fblockpos[0], self.a_blockpos[0], verbose)


      
    def writeFile(self, filename):
       
#        Write this topology to file
    
#        Write out this topology in Desmond format
        
#        Args:
#            filename: the name of the file to write out to
              
      verbose = True 
      lines = list()
      vdwtypes = []
      sites = []
      pos = 0
      name = ''
      sig = None 
      ep = None
      stemp = None
      etemp = None

      print "WARNING: MacroModel atom type is set to 7 for all cases."
      
      # for all CMS files
      lines.append('{\n')
      lines.append('  s_m_m2io_version\n')
      lines.append('  :::\n')
      lines.append('  2.0.0\n')
      lines.append('}\n')
      
      #FIRST F_M_CT BLOCK
      
      if verbose:
        print "Writing first f_m_ct..."
      lines.append('f_m_ct {\n')
      lines.append('  s_m_title\n')
      lines.append('  r_chorus_box_ax\n')
      lines.append('  r_chorus_box_ay\n')
      lines.append('  r_chorus_box_az\n')
      lines.append('  r_chorus_box_bx\n')
      lines.append('  r_chorus_box_by\n')
      lines.append('  r_chorus_box_bz\n')
      lines.append('  r_chorus_box_cx\n')
      lines.append('  r_chorus_box_cy\n')
      lines.append('  r_chorus_box_cz\n')
      lines.append('  s_ffio_ct_type\n')
      lines.append('  :::\n')
      
      #box vector
      bv = System._sys.getBoxVector()
      lines.append('  "full system"\n')
      lines.append('%22s\n'%float(bv[0][0]._value))
      lines.append('%22s\n'%float(bv[1][0]._value))
      lines.append('%22s\n'%float(bv[2][0]._value))
      lines.append('%22s\n'%float(bv[0][1]._value))
      lines.append('%22s\n'%float(bv[1][1]._value))
      lines.append('%22s\n'%float(bv[2][1]._value))
      lines.append('%22s\n'%float(bv[0][2]._value))
      lines.append('%22s\n'%float(bv[1][2]._value))
      lines.append('%22s\n'%float(bv[2][2]._value))
      lines.append('  full_system\n')
      
      #M_ATOM
      apos = len(lines) #pos of where m_atom will be; will need to overwite later based on the number of atoms
      lines.append('m_atom\n')
      lines.append('    # First column is atom index #\n')
      lines.append('    i_m_mmod_type\n')
      lines.append('    r_m_x_coord\n')
      lines.append('    r_m_y_coord\n')
      lines.append('    r_m_z_coord\n')
      lines.append('    i_m_residue_number\n')
      lines.append('    s_m_pdb_residue_name\n')
      lines.append('    i_m_atomic_number\n')
      lines.append('    s_m_atom_name\n')
      lines.append('    r_ffio_x_vel\n')
      lines.append('    r_ffio_y_vel\n')
      lines.append('    r_ffio_z_vel\n')
      lines.append('    :::\n')

      i = 0
      for moleculetype in System._sys._molecules.values():
        for molecule in moleculetype.moleculeSet:
          for atom in molecule._atoms:
            i += 1
	    lines.append('    %d        %d   %10.8f %10.8f %10.8f     %2d %4s    %2d  %2s    %11.8f %11.8f %11.8f\n'
                        %(i,
			7, #NOT SURE WHAT TO PUT FOR MMOD TYPE
			float(atom._position[0]._value)*10,
                        float(atom._position[1]._value)*10,
                        float(atom._position[2]._value)*10,
			atom.residueIndex,
                        '"%s"'%atom.residueName,
			atom.atomIndex,
			'"%s"'%atom.atomName,
                        float(atom._velocity[0]._value)*10,
                        float(atom._velocity[1]._value)*10,
                        float(atom._velocity[2]._value)*10))
      if i == 0:
        j = 1
	if verbose:
	  print "REMOVING M_ATOMS FROM BEGINNING"
        while j <= 13:
	  del lines[-1]
	  j+=1
      else:
        lines[apos] = '  m_atom[%d] {\n'%(i)
        lines.append('    :::\n')
        lines.append('  }\n')
      
      bpos = len(lines) 
      i = 0
      
      #M_BOND
      lines.append('  m_bond\n')
      lines.append('    i_m_from\n')
      lines.append('    i_m_to\n')
      lines.append('    i_m_order\n')
      lines.append('    i_m_from_rep\n')
      lines.append('    i_m_to_rep\n')
      lines.append('    :::\n')
      
      i = 0
      nonecnt = 0
      for moleculetype in System._sys._molecules.values():
        for bond in moleculetype.bondForceSet.itervalues():
          if bond and bond.order:
            i += 1
            lines.append('    %d %d %d %d %d %d\n'
                          %(i,
		  	  bond.atom1,
                          bond.atom2,
                          int(bond.order),
			  1,
			  1))
          elif not bond:
            nonecnt+=1
      if nonecnt > 0 and verbose:
        print 'FOUND %d BONDS THAT DO NOT EXIST'%nonecnt
      if i == 0:
	if verbose:
	  print "REMOVING M_BONDS FROM BEGINNING"
        j = 1
        while j <= 7:
	  del lines[-1]
	  j+=1
      else:
        lines[bpos] = '  m_bond[%d] {\n'%i
        lines.append('    :::\n')
        lines.append('  }\n')
        lines.append('}\n')

      solute = True
      endline = ''
      resName = ''

      #WRITE OUT ALL FFIO AND F_M_CT BLOCKS

      for moleculetype in System._sys._molecules.values():
        for molecule in moleculetype.moleculeSet:
          if verbose:
            print 'Writing molecule %s...'%moleculetype.name

          #BEGINNING BLOCK
                 
          if verbose:
            print "  Writing f_m_ct..."
          lines.append('f_m_ct {\n')
          lines.append('  s_m_title\n')
          bpos = len(lines) #bpos temporarily used for position of s_m_entry_name (for TIP3)
	  lines.append('  s_m_entry_name\n')
          lines.append('  i_ffio_num_component\n')  
	  lines.append('  r_chorus_box_ax\n')
          lines.append('  r_chorus_box_ay\n')
          lines.append('  r_chorus_box_az\n')
          lines.append('  r_chorus_box_bx\n')
          lines.append('  r_chorus_box_by\n')
          lines.append('  r_chorus_box_bz\n')
          lines.append('  r_chorus_box_cx\n')
          lines.append('  r_chorus_box_cy\n')
          lines.append('  r_chorus_box_cz\n')
          lines.append('  s_ffio_ct_type\n')
          lines.append('  :::\n')
          
          if solute:
            lines.append('  solute\n')
            endline = '  solute\n'
            solute = False
	    del lines[bpos]
            del lines[bpos]
          else:
            for atom in molecule._atoms:
              resName = atom.residueName
	      break
            if re.match("T3P", resName) or re.search("WAT", resName):
	      #lines[bpos] = ('  s_m_entry_name\n')
              lines.append('  "TIP3P water box"\n')
              lines.append('  "TIP3P water box"\n')
              lines.append('  1\n')
              endline = '  solvent\n'
            else:
              lines.append('  %s\n'%(moleculetype.name))
              endline = '  ion\n'
	      del lines[bpos]
              del lines[bpos] #deletes line for num component (only in TIP3)
      
          lines.append('%22s\n'%float(bv[0][0]._value))
          lines.append('%22s\n'%float(bv[1][0]._value))
          lines.append('%22s\n'%float(bv[2][0]._value))
          lines.append('%22s\n'%float(bv[0][1]._value))
          lines.append('%22s\n'%float(bv[1][1]._value))
          lines.append('%22s\n'%float(bv[2][1]._value))
          lines.append('%22s\n'%float(bv[0][2]._value))
          lines.append('%22s\n'%float(bv[1][2]._value))
          lines.append('%22s\n'%float(bv[2][2]._value))
          lines.append(endline)
          
          #M_ATOMS
          
          if verbose:
            print "  Writing m_atoms..."
          apos = len(lines) #pos of where m_atom will be; will need to overwite later based on the number of atoms
          lines.append('m_atom\n')
          lines.append('    # First column is atom index #\n')
          lines.append('    i_m_mmod_type\n')
          lines.append('    r_m_x_coord\n')
          lines.append('    r_m_y_coord\n')
          lines.append('    r_m_z_coord\n')
          lines.append('    i_m_residue_number\n')
          lines.append('    s_m_pdb_residue_name\n')
	  lines.append('    i_m_atomic_number\n')
          lines.append('    s_m_atom_name\n')
          lines.append('    r_ffio_x_vel\n')
          lines.append('    r_ffio_y_vel\n')
          lines.append('    r_ffio_z_vel\n')
          lines.append('    :::\n')

          i = 0
          for atom in molecule._atoms:
            i += 1
	    lines.append('    %d        %d   %10.8f %10.8f %10.8f     %2d %4s    %2d  %2s   %11.8f %11.8f %11.8f\n'
                        %(i,
			7, #NOT SURE WHAT TO PUT FOR MMOD TYPE
			float(atom._position[0]._value)*10,
                        float(atom._position[1]._value)*10,
                        float(atom._position[2]._value)*10,
			atom.residueIndex,
                        '"%s"'%atom.residueName,
			atom.atomIndex,
			'"%s"'%atom.atomName,
                        float(atom._velocity[0]._value)*10,
                        float(atom._velocity[1]._value)*10,
                        float(atom._velocity[2]._value)*10))
	  if i == 0:
            j = 1
	    if verbose:
	      print "REMOVING M_ATOMS FROM BEGINNING"
            while j <=13: 
	      del lines[-1]
	      j+=1
          else:
            lines[apos] = '  m_atom[%d] {\n'%(i)
            lines.append('    :::\n')
            lines.append('  }\n')

          #M_BONDS
      
          if verbose:
            print "  Writing m_bonds..."
          bpos = len(lines) 
          i = 0
      
          lines.append('  m_bond\n')
          lines.append('    i_m_from\n')
          lines.append('    i_m_to\n')
          lines.append('    i_m_order\n')
          lines.append('    i_m_from_rep\n')
          lines.append('    i_m_to_rep\n')
          lines.append('    :::\n')
      
          i = 0
          nonecnt = 0
          for bond in moleculetype.bondForceSet.itervalues():
	    if bond and bond.order:
              i += 1
              lines.append('    %d %d %d %d %d %d\n'
                          %(i,
                           bond.atom1,
                           bond.atom2,
                           int(bond.order),
			   1,
			   1))
            else:
              nonecnt+=1
          if nonecnt > 0 and verbose:
            print 'FOUND %d BONDS THAT DO NOT EXIST'%nonecnt
          if i == 0:
	    if verbose:
	      print "REMOVING M_BONDS FROM BEGINNING"
            j = 1
            while j <= 7:
	      del lines[-1]
	      j+=1
          else:
            lines[bpos] = '  m_bond[%d] {\n'%i
            lines.append('    :::\n')
            lines.append('  }\n')

          #FFIO 
        
          if verbose:
            print "  Writing ffio..."
          lines.append('  ffio_ff {\n')
          lines.append('    s_ffio_name\n')
          lines.append('    s_ffio_comb_rule\n')
          lines.append('    i_ffio_version\n')
          lines.append('    :::\n')
        
          #Adding Molecule Name
          if re.search("Viparr", moleculetype.name): 
            lines.append('    Generated by Viparr\n') 
          else:
            #print moleculetype.name
            lines.append('    %s\n' % moleculetype.name)

          #Adding Combination Rule
          if System._sys._combinationRule == 1:
            lines.append('    ARITHMETIC\n') #NOT SURE WHAT TO PUT HERE...COME BACK TO THIS
          elif System._sys._combinationRule == 2:
            lines.append('    GEOMETRIC\n')    
	  elif System._sys._combinationRule == 3:
	    lines.append('    ARITHMETIC/GEOMETRIC\n') 
        
          #Adding Version
          lines.append('    1.0.0\n') #All files had this, check if version is 1.0.0

          #-ADDING VDWTYPES AND SITES
          i = 1
          vdwtypes = []
          sites = []
	  sig = None
	  ep = None
	  stemp = None
	  etemp = None
	  combRule = System._sys._combinationRule
          if re.search("solute", moleculetype.name): #ALL ATOMS
            for atom in molecule._atoms:
              if atom.residueIndex:
                sites.append(' %3d %5s %9.8f %9.8f %2s %1d %4s\n' % (i,'atom',float(atom._charge[0]._value),float(atom._mass[0]._value),atom._atomtype[0],atom.residueIndex,atom.residueName)) 
              else:
                sites.append(' %3d %5s %9.8f %9.8f %2s\n' % (i,'atom',float(atom._charge[0]._value),float(atom._mass[0]._value),atom._atomtype[0]))
	      sig = float(atom._sigma[0]._value)
	      ep = float(atom._epsilon[0]._value)
	      if combRule == 1:
	        stemp = ep * (4 * (sig**6))
	        etemp = stemp * (sig**6)
	      elif combRule == 2 or combRule == 3:
	        stemp = sig
		etemp = ep
              if ' %2s %18s %8.8f %8.8f\n' % (atom._atomtype[0],"LJ12_6_sig_epsilon",float(10*stemp),float(etemp/4.184)) not in vdwtypes:
                vdwtypes.append(' %2s %18s %8.8f %8.8f\n' % (atom._atomtype[0],"LJ12_6_sig_epsilon",float(10*stemp),float(etemp/4.184)))
              i+=1
          elif re.search("H2O", moleculetype.name): #FOR WATER
            for k in range(0,3):
              if molecule._atoms[k].residueIndex:
                sites.append(' %3d %5s %9.8f %9.8f %2s %1d %4s\n' % (k+1,'atom',float(molecule._atoms[k]._charge[0]._value),float(molecule._atoms[k]._mass[0]._value),molecule._atoms[k]._atomtype[0],molecule._atoms[k].residueIndex,molecule._atoms[k].residueName)) 
              else:
                sites.append(' %3d %5s %9.8f %9.8f %2s\n' % (k+1,'atom',float(molecule._atoms[k]._charge[0]._value),float(molecule._atoms[k]._mass[0]._value),molecule._atoms[k]._atomtype[0]))
	      sig = float(molecule._atoms[k]._sigma[0]._value)
	      ep = float(molecule._atoms[k]._epsilon[0]._value)
	      if combRule == 1:
	        stemp = ep * (4 * (sig**6))
	        etemp = stemp * (sig**6)
	      elif combRule == 2 or combRule == 3:
	        stemp = sig
		etemp = ep
              if ' %2s %18s %8.8f %8.8f\n' % (molecule._atoms[k]._atomtype[0],"LJ12_6_sig_epsilon",float(10*stemp),float(etemp/4.184)) not in vdwtypes:
                vdwtypes.append(' %2s %18s %8.8f %8.8f\n' % (molecule._atoms[k]._atomtype[0],"LJ12_6_sig_epsilon",float(10*stemp),float(etemp/4.184)))
          else: #FOR OTHERS WITH CL-, Na+, AND SUCH--MAY HAVE TO EDIT TO FIT OTHERS
            if molecule._atoms[0].residueIndex:
              sites.append(' %3d %5s %9.8f %9.8f %2s %1d %4s\n' % (1,'atom',float(molecule._atoms[0]._charge[0]._value),float(molecule._atoms[0]._mass[0]._value),molecule._atoms[0]._atomtype[0],molecule._atoms[0].residueIndex,molecule._atoms[0].residueName)) 
            else:
              sites.append(' %3d %5s %9.8f %9.8f %2s\n' % (1,'atom',float(molecule._atoms[0]._charge[0]._value),float(molecule._atoms[0]._mass[0]._value),molecule._atoms[0]._atomtype[0]))
	    sig = float(molecule._atoms[0]._sigma[0]._value)
	    ep = float(molecule._atoms[0]._epsilon[0]._value)
	    if combRule == 1:
	      stemp = ep * (4 * (sig**6))
	      etemp = stemp * (sig**6)
	    elif combRule == 2 or combRule == 3:
	      stemp = sig
	      etemp = ep
            vdwtypes.append(' %2s %18s %8.8f %8.8f\n' % (molecule._atoms[0]._atomtype[0],"LJ12_6_sig_epsilon",float(10*stemp),float(etemp/4.184)))
        
          if verbose:
            print "   -Writing vdwtypes..."
	  if len(vdwtypes) > 0:
	    lines.append("    ffio_vdwtypes[%d] {\n"%(len(vdwtypes)))
            lines.append("      s_ffio_name\n")
            lines.append("      s_ffio_funct\n")
            lines.append("      r_ffio_c1\n")
            lines.append("      r_ffio_c2\n")
            lines.append("      :::\n")
	    i = 1
            for v in vdwtypes:
              lines.append('      %d%2s'%(i,v))
	      i+=1
            lines.append("      :::\n")
            lines.append("    }\n")
	  else:
	    if verbose:
              print "REMOVING VDWTYPES"
          
          if verbose:
            print "   -Writing sites..."
	  if len(sites) > 0:
            lines.append("    ffio_sites[%d] {\n"%(len(sites)))
            lines.append("      s_ffio_type\n")
            lines.append("      r_ffio_charge\n")
            lines.append("      r_ffio_mass\n")
            lines.append("      s_ffio_vdwtype\n")
            if len(sites[0]) > 4:
              lines.append("      i_ffio_resnr\n")
              lines.append("      s_ffio_residue\n")    
            lines.append("      :::\n")
            for s in sites:
              lines.append('   %s'%(s))
            lines.append("      :::\n")
            lines.append("    }\n")
	  else:
	    if verbose:
              print "REMOVING SITES"
	  
	  #-ADDING BONDS
          if verbose:
            print "   -Writing bonds..."
	  bpos = len(lines)
          lines.append("    ffio_bonds\n")
          lines.append("      i_ffio_ai\n")
          lines.append("      i_ffio_aj\n")
          lines.append("      s_ffio_funct\n")
          lines.append("      r_ffio_c1\n")
          lines.append("      r_ffio_c2\n")
          lines.append("      :::\n")
	  i = 0
	  nonecnt = 0
	  name = ''
	  length = None
	  k = None
	  
          for bond in moleculetype.bondForceSet.itervalues():
	    try:
	      length = float(bond.length._value * 10)
	      k = float(bond.k._value / (4.184 * 100))
            except:
	      length = None
	      k = None
	    if bond and (length and not length == float(0)) and (k and not k == float(0)):  #Probably a better way to sort sites from m_bond
              i += 1
	      if bond.c == 1:
	        name = 'Harm_constrained'
	      else:
	        name = 'Harm'
              lines.append('      %d %d %d %s %10.8f %10.8f\n'
                          %(i,
                           bond.atom1,
                           bond.atom2,
                           name,
			   length,
			   k))
            elif not bond:
              nonecnt+=1
          if nonecnt > 0 and verbose:
            print 'FOUND %d BONDS THAT DO NOT EXIST'%nonecnt
	  if i == 0:
	    if verbose:
	      print "REMOVING FFIO_BONDS FROM BEGINNING"
            j = 1
            while j <= 7:
	      del (lines[-1])
	      j+=1
          else:
	    lines.append("      :::\n")
            lines.append("    }\n")
            lines[bpos] = ("    ffio_bonds[%d] {\n"%(i))

          #-ADDING ANGLES 
          if verbose:
            print "   -Writing angles..."
	  bpos = len(lines) #storing position for angles instead of bonds
          lines.append("    ffio_angles\n")
          lines.append("      i_ffio_ai\n")
          lines.append("      i_ffio_aj\n")
          lines.append("      i_ffio_ak\n")
          lines.append("      s_ffio_funct\n")
          lines.append("      r_ffio_c1\n")
          lines.append("      r_ffio_c2\n")
          lines.append("      :::\n")
	  i = 1
          for angle in moleculetype.angleForceSet.itervalues():
            if angle.c == 0:
              lines.append('      %d %d %d %d %s %10.8f %10.8f\n' % (i, angle.atom1, angle.atom2, angle.atom3, 'Harm', float(angle.theta._value), float(angle.k._value)))
            elif angle.c == 1:
              lines.append('      %d %d %d %d %s %10.8f %10.8f\n' % (i, angle.atom1, angle.atom2, angle.atom3, 'Harm_constrained', float(angle.theta._value), float(angle.k._value)))
            i+=1
	  if i == 1:
	    if verbose:
	      print "REMOVING FFIO_ANGLES FROM BEGINNING"
            j = 1
            while j <= 8:
	      del lines[-1]
	      j+=1
          else:
            lines.append("      :::\n")
            lines.append("    }\n")
            lines[bpos] = ("    ffio_angles[%d] {\n"%(i-1))

          #-ADDING DIHEDRALS
          if verbose:
            print "   -Writing dihedrals..."
          bpos = len(lines) #storing position for dihedrals instead of bonds
          lines.append("    ffio_dihedrals\n")
          lines.append("      i_ffio_ai\n")
          lines.append("      i_ffio_aj\n")
          lines.append("      i_ffio_ak\n")
          lines.append("      i_ffio_al\n")
          lines.append("      s_ffio_funct\n")
	  i = 1
          for dihedral in moleculetype.dihedralForceSet.itervalues():
            if isinstance(dihedral, ProperDihedral1) or isinstance(dihedral, ProperDihedral9):
              if i == 1:
                lines.append("      r_ffio_c0\n")
                lines.append("      r_ffio_c1\n")
                lines.append("      r_ffio_c2\n")
                lines.append("      :::\n")
	      lines.append('      %d %d %d %d %d %s %10.8f %10.8f %10.8f\n'%(i, dihedral.atom1, dihedral.atom2, dihedral.atom3, dihedral.atom4, 'Proper_Harm', float(dihedral.phi._value), float(dihedral.k._value)  * ((0.01745)**(2)) / 4.184, int(dihedral.multiplicity)))
            elif isinstance(dihedral, ImproperDihedral2): 
              if i == 1:
                lines.append("      r_ffio_c0\n")
                lines.append("      r_ffio_c1\n")
                lines.append("      :::\n")
              lines.append('      %d %d %d %d %d %s %10.8f %10.8f\n'%(i, dihedral.atom1, dihedral.atom2, dihedral.atom3, dihedral.atom4, 'Improper_Harm', float(dihedral.xi._value), float(dihedral.k._value) * ((0.01745)**(2)) / 4.184))
	    elif isinstance(dihedral, RBDihedral):
	      if i == 1:
                lines.append("      r_ffio_c0\n")
                lines.append("      r_ffio_c1\n")
                lines.append("      r_ffio_c2\n")
                lines.append("      r_ffio_c3\n")
                lines.append("      r_ffio_c4\n")
                lines.append("      r_ffio_c5\n")
                lines.append("      r_ffio_c6\n")
                lines.append("      r_ffio_c7\n")
                lines.append("      :::\n")
	      if dihedral.i == 1:
	        name = 'Improper_Trig'
	      else:
	        name = 'Proper_Trig'
	      lines.append('      %d %d %d %d %d %s %10.8f %10.8f %10.8f %10.8f %10.8f %10.8f %10.8f %d\n'%(i, dihedral.atom1, dihedral.atom2, dihedral.atom3, dihedral.atom4, name, float(dihedral.C0._value) / 4.184, float(dihedral.C1._value) / 4.184, float(dihedral.C2._value) / 4.184, float(dihedral.C3._value) / 4.184, float(dihedral.C4._value) / 4.184, float(dihedral.C5._value) / 4.184, float(0), 0))
            else:
	      print "ERROR (writeFile): found unsupported dihedral"
	    i+=1
          if i == 1:
	    if verbose:
	      print "REMOVING FFIO_DIHEDRALS FROM BEGINNING"
            j = 1
            while j <= 6:
	      del lines[-1]
	      j+=1
          else:
	    lines.append("      :::\n")
            lines.append("    }\n")
            lines[bpos] = ("    ffio_dihedrals[%d] {\n"%(i-1))
	
	 #ADDING EXCLUSIONS
          i = 1
          if verbose:
            print "   -Writing exclusions..."
          bpos = len(lines) #storing position for exclusions instead of bonds
          lines.append("    ffio_exclusions\n")
          lines.append("      i_ffio_ai\n")
          lines.append("      i_ffio_aj\n")
	  lines.append("      :::\n")
	  for exclusion in moleculetype.exclusions.itervalues():
            lines.append('      %d %d %d\n'%(i, int(exclusion.exclusions[0]), int(exclusion.exclusions[1])))
	    i+=1
          if i == 1:
	    if verbose:
	      print "REMOVING FFIO_EXCLUSIONS FROM BEGINNING"
            j = 1
            while j <= 4:
	      del lines[-1]
	      j+=1
	  else:
            lines.append("      :::\n")
            lines.append("    }\n")
            lines[bpos] = ("    ffio_exclusions[%d] {\n"%(i-1))

          #-ADDING PAIRS
          if verbose:
            print "   -Writing pairs..."
	  bpos = len(lines) #storing position for pairs instead of bonds
          lines.append("    ffio_pairs\n")
          lines.append("      i_ffio_ai\n")
          lines.append("      i_ffio_aj\n")
          lines.append("      s_ffio_funct\n")
          lines.append("      r_ffio_c1\n")
          lines.append("      :::\n")
	  i = 1
          for pair in moleculetype.pairForceSet.itervalues():
            if re.match("LJ", pair.type):
              lines.append('      %d %d %d %s %10.8f\n' % (i, pair.atom1, pair.atom2, pair.type, System._sys._ljCorrection))
            elif re.match("Coulomb", pair.type):
              lines.append('      %d %d %d %s %10.8f\n' % (i, pair.atom1, pair.atom2, pair.type, System._sys._coulombCorrection))
            elif re.match("Both", pair.type):
              lines.append('      %d %d %d %s %10.8f\n' % (i, pair.atom1, pair.atom2, "LJ", System._sys._ljCorrection))
              i+=1
              lines.append('      %d %d %d %s %10.8f\n' % (i, pair.atom1, pair.atom2, "Coulomb", System._sys._coulombCorrection))
            i+=1
          if i == 1:
	    if verbose:
	      print "REMOVING FFIO_PAIRS FROM BEGINNING"
            j = 1
            while j <= 6:
	      del lines[-1]
	      j+=1
	  else:
            lines.append("      :::\n")
            lines.append("    }\n")
            lines[bpos] = ("    ffio_pairs[%d] {\n"%(i-1))
	  
	  #ADDING RESTRAINTS
	  
	  #ADDING CONSTRAINTS
          i = 1
	  j = 0
          if verbose:
            print "   -Writing constraints..."
          bpos = len(lines) #storing position for constraints instead of bonds
          isHOH = False
          alen = 0
	  alen_max = 0
          atomlst = []
          lenlst = []
	  lines.append("    ffio_constraints\n")
	  for constraint in moleculetype.constraints.itervalues(): #calculate the max number of atoms in constraint
            if re.search('AH',constraint.type):
	      alen = int(list(constraint.type)[-1])
            elif re.match('HOH',constraint.type):
	      alen = 2
	    if alen_max < alen:
	      alen_max = alen
	  for constraint in moleculetype.constraints.itervalues(): 
            if re.search('AH',constraint.type):
	      alen = int(list(constraint.type)[-1])
            elif re.match('HOH',constraint.type):
	      alen = 2
              isHOH = True
	    lines.append('      ')
	    if alen == 1:
	      lines.append('%d %d %d '%(i,int(constraint.atom1),int(constraint.atom2)))
	      if alen_max > alen:
	        j = alen
		while j < alen_max:
		  lines.append('%s '%'<>')
		  j+=1
              lines.append('%s '%'AH1')
	      lines.append('%10.8f '%(float(constraint.length1._value*10)))
	      if alen_max > alen:
	        j = alen
		while j < alen_max:
		  lines.append('%s '%'<>')
		  j+=1
	      lines.append('\n')
	    elif alen == 2:
	      lines.append('%d %d %d %d '%(i,int(constraint.atom1),int(constraint.atom2),int(constraint.atom3)))
	      if alen_max > alen:
	        j = alen
		while j < alen_max:
		  lines.append('%s '%'<>')
		  j+=1
              lines.append('%s '%(constraint.type))
	      if re.match('HOH',constraint.type):
	        lines.append('%10.8f %10.8f %10.8f\n'%(float(constraint.length1._value*10),float(constraint.length2._value*10),float(constraint.length3._value*10)))
	      else:
		lines.append('%10.8f %10.8f '%(float(constraint.length1._value*10),float(constraint.length2._value*10)))
	        if alen_max > alen:
	          j = alen
		  while j < alen_max:
		    lines.append('%s '%'<>')
		    j+=1
	        lines.append('\n')
	    elif alen == 3:
	      lines.append('%d %d %d %d %d '%(i,int(constraint.atom1),int(constraint.atom2),int(constraint.atom3),int(constraint.atom4)))
	      if alen_max > alen:
	        j = alen
		while j < alen_max:
		  lines.append('%s '%'<>')
		  j+=1
              lines.append('%s '%'AH3')
	      lines.append('%10.8f %10.8f %10.8f '%(float(constraint.length1._value*10),float(constraint.length2._value*10),float(constraint.length3._value*10)))
	      if alen_max > alen:
	        j = alen
		while j < alen_max:
		  lines.append('%s '%'<>')
		  j+=1
	      lines.append('\n')
	    elif alen == 4:
	      lines.append('%d %d %d %d %d %d '%(i,int(constraint.atom1),int(constraint.atom2),int(constraint.atom3),int(constraint.atom4),int(constraint.atom5)))
	      if alen_max > alen:
	        j = alen
		while j < alen_max:
		  lines.append('%s '%'<>')
		  j+=1
              lines.append('%s '%'AH4')
	      lines.append('%10.8f %10.8f %10.8f %10.8f '%(float(constraint.length1._value*10),float(constraint.length2._value*10),float(constraint.length3._value*10),float(constraint.length4._value*10)))
	      if alen_max > alen:
	        j = alen
		while j < alen_max:
		  lines.append('%s '%'<>')
		  j+=1
	      lines.append('\n')
	    elif alen == 5:
	      lines.append('%d %d %d %d %d %d %d '%(i,int(constraint.atom1),int(constraint.atom2),int(constraint.atom3),int(constraint.atom4),int(constraint.atom5),int(constraint.atom6)))
	      if alen_max > alen:
	        j = alen
		while j < alen_max:
		  lines.append('%s '%'<>')
		  j+=1
              lines.append('%s '%'AH5')
	      lines.append('%10.8f %10.8f %10.8f %10.8f %10.8f '%(float(constraint.length1._value*10),float(constraint.length2._value*10),float(constraint.length3._value*10),float(constraint.length4._value*10),float(constraint.length5._value*10)))
	      if alen_max > alen:
	        j = alen
		while j < alen_max:
		  lines.append('%s '%'<>')
		  j+=1
	      lines.append('\n')
	    elif alen == 6:
	      lines.append('%d %d %d %d %d %d %d %d '%(i,int(constraint.atom1),int(constraint.atom2),int(constraint.atom3),int(constraint.atom4),int(constraint.atom5),int(constraint.atom6),int(constraint.atom7)))
	      if alen_max > alen:
	        j = alen
		while j < alen_max:
		  lines.append('%s '%'<>')
		  j+=1
              lines.append('%s '%'AH6')
	      lines.append('%10.8f %10.8f %10.8f %10.8f %10.8f %10.8f '%(float(constraint.length1._value*10),float(constraint.length2._value*10),float(constraint.length3._value*10),float(constraint.length4._value*10),float(constraint.length5._value*10),float(constraint.length6._value*10)))
	      if alen_max > alen:
	        j = alen
		while j < alen_max:
		  lines.append('%s '%'<>')
		  j+=1
	      lines.append('\n')
	    elif alen == 7:
	      lines.append('%d %d %d %d %d %d %d %d %d '%(i,int(constraint.atom1),int(constraint.atom2),int(constraint.atom3),int(constraint.atom4),int(constraint.atom5),int(constraint.atom6),int(constraint.atom7),int(constraint.atom8)))
	      if alen_max > alen:
	        j = alen
		while j < alen_max:
		  lines.append('%s '%'<>')
		  j+=1
              lines.append('%s '%'AH7')
	      lines.append('%10.8f %10.8f %10.8f %10.8f %10.8f %10.8f %10.8f '%(float(constraint.length1._value*10),float(constraint.length2._value*10),float(constraint.length3._value*10),float(constraint.length4._value*10),float(constraint.length5._value*10),float(constraint.length6._value*10),float(constraint.length7._value*10)))
	      if alen_max > alen:
	        j = alen
		while j < alen_max:
		  lines.append('%s '%'<>')
		  j+=1
	      lines.append('\n')
	    elif alen == 8:
	      lines.append('%d %d %d %d %d %d %d %d %d %d '%(i,int(constraint.atom1),int(constraint.atom2),int(constraint.atom3),int(constraint.atom4),int(constraint.atom5),int(constraint.atom6),int(constraint.atom7),int(constraint.atom8),int(constraint.atom9)))
	      if alen_max > alen:
	        j = alen
		while j < alen_max:
		  lines.append('%s '%'<>')
		  j+=1
              lines.append('%s '%'AH8')
	      lines.append('%10.8f %10.8f %10.8f %10.8f %10.8f %10.8f %10.8f %10.8f '%(float(constraint.length1._value*10),float(constraint.length2._value*10),float(constraint.length3._value*10),float(constraint.length4._value*10),float(constraint.length5._value*10),float(constraint.length6._value*10),float(constraint.length7._value*10),float(constraint.length8._value*10)))
	      if alen_max > alen:
	        j = alen
		while j < alen_max:
		  lines.append('%s '%'<>')
		  j+=1
	      lines.append('\n')
	    i+=1
	  if i == 1:
	    if verbose:
	      print "REMOVING FFIO_CONSTRAINTS FROM BEGINNING"
            j = 1
            while j <= 1:
	      del lines[-1]
	      j+=1
	  else:
            lines.append("      :::\n")
            lines.append("    }\n")
            lines[bpos] = ("    ffio_constraints[%d] {\n"%(i-1))
	    bpos+=1
	    lines.insert(bpos,"      :::\n")
	    j = alen_max
            if isHOH:
              j+=1
	    while j >=1:
              lines.insert(bpos,'      r_ffio_c%d\n'%j)
              j-=1
	    lines.insert(bpos,"      s_ffio_funct\n")
	    if alen_max >= 1: 
  	      lines.insert(bpos,"      i_ffio_ai\n")
	      bpos+=1
              lines.insert(bpos,"      i_ffio_aj\n")
	    if alen_max >= 2:
  	      bpos+=1
              lines.insert(bpos,"      i_ffio_ak\n")
	    if alen_max>= 3:
	      bpos+=1
              lines.insert(bpos,"      i_ffio_al\n")
	    if alen_max >= 4:
              bpos+=1
              lines.insert(bpos,"      i_ffio_am\n")
	    if alen_max >= 5:
  	      bpos+=1
              lines.insert(bpos,"      i_ffio_an\n")
	    if alen_max >= 6:
	      bpos+=1
	      lines.insert(bpos,"      i_ffio_ao\n")
            if alen_max >= 7:
              bpos+=1
              lines.insert(bpos,"      i_ffio_ap\n")
            if alen_max == 8:
              bpos+=1
              lines.insert(bpos,"      i_ffio_aq\n")

	  lines.append("  }\n")
          lines.append("}\n")

      fout = open(filename, 'w')
      for line in lines:
        fout.write(line)
      fout.close() 
